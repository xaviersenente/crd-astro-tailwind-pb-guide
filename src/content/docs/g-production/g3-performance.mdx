---
title: Performance
description: Optimiser images, rendu, cache et pagination
---

## Optimisation des images

### Utiliser le composant Image d'Astro

```astro
---
import { Image } from 'astro:assets';
import heroImage from '../assets/hero.jpg';
---

<Image
  src={heroImage}
  alt="Conservatoire"
  width={1200}
  height={800}
  loading="lazy"
  format="webp"
  quality={80}
/>
```

### Images responsives

```astro
<Image
  src={image}
  alt="Évènement"
  widths={[400, 800, 1200]}
  sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
  format="webp"
/>
```

### Lazy loading

```astro
<!-- Images au-dessus de la ligne de flottaison -->
<Image src={hero} alt="Hero" loading="eager" />

<!-- Images en bas de page -->
<Image src={thumbnail} alt="Thumbnail" loading="lazy" />
```

### Optimiser les images PocketBase

```ts
// src/lib/pocketbase.ts
export function getImageUrl(
  collectionId: string,
  recordId: string,
  filename: string,
  size?: "small" | "medium" | "large",
): string {
  const thumbSizes = {
    small: "300x200",
    medium: "600x400",
    large: "1200x800",
  };

  const thumb = size ? thumbSizes[size] : undefined;
  let url = `${PB_URL}/api/files/${collectionId}/${recordId}/${filename}`;

  if (thumb) {
    url += `?thumb=${thumb}`;
  }

  return url;
}
```

## Optimisation du rendu

### Preload des ressources critiques

```astro
<head>
  <!-- Preload fonts -->
  <link
    rel="preload"
    href="/fonts/inter-var.woff2"
    as="font"
    type="font/woff2"
    crossorigin
  />

  <!-- Preload hero image -->
  <link rel="preload" as="image" href="/images/hero.webp" />
</head>
```

### Prefetch des pages

```astro
---
// Prefetch les pages importantes
---

<link rel="prefetch" href="/agenda" />
<link rel="prefetch" href="/contact" />
```

### Defer des scripts non essentiels

```astro
<script src="/js/analytics.js" defer></script>
```

## Cache et performances

### Configuration du cache (Vercel)

`vercel.json` :

```json
{
  "headers": [
    {
      "source": "/images/(.*)",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=31536000, immutable"
        }
      ]
    },
    {
      "source": "/fonts/(.*)",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=31536000, immutable"
        }
      ]
    }
  ]
}
```

### Configuration du cache (Netlify)

`netlify.toml` :

```toml
[[headers]]
  for = "/images/*"
  [headers.values]
    Cache-Control = "public, max-age=31536000, immutable"

[[headers]]
  for = "/fonts/*"
  [headers.values]
    Cache-Control = "public, max-age=31536000, immutable"

[[headers]]
  for = "/*.css"
  [headers.values]
    Cache-Control = "public, max-age=31536000, immutable"

[[headers]]
  for = "/*.js"
  [headers.values]
    Cache-Control = "public, max-age=31536000, immutable"
```

## Pagination efficace

### Limiter le nombre de résultats

```ts
// src/lib/api.ts
export async function getUpcomingEvents(limit = 12): Promise<Event[]> {
  // Ne récupérer que le nécessaire
  const result = await pb.collection("event").getList<Event>(1, limit, {
    filter: 'date >= @now && status = "published"',
    sort: "date",
    expand: "category",
  });

  return result.items;
}
```

### Pagination côté serveur

```astro
---
// src/pages/agenda/[page].astro
export const getStaticPaths: GetStaticPaths = async ({ paginate }) => {
  const PAGE_SIZE = 12;
  const events = await getPublishedEvents();
  return paginate(events, { pageSize: PAGE_SIZE });
};
---
```

## Minification et compression

### Configuration Astro

```js
// astro.config.mjs
export default defineConfig({
  build: {
    inlineStylesheets: "auto",
  },
  vite: {
    build: {
      minify: "terser",
      terserOptions: {
        compress: {
          drop_console: true, // Supprimer les console.log en prod
        },
      },
    },
  },
});
```

### Compression gzip/brotli

Activée automatiquement par la plupart des hébergeurs (Vercel, Netlify).

## Optimisation Tailwind

Purger les classes inutilisées :

```js
// tailwind.config.mjs
export default {
  content: ["./src/**/*.{astro,html,js,jsx,md,mdx,svelte,ts,tsx,vue}"],
  // ... config
};
```

## Lazy load des composants

### Vue Components (optionnel)

```astro
---
// Lazy import d'un composant lourd
const HeavyComponent = import('../components/HeavyComponent.astro');
---

{condition && <HeavyComponent />}
```

### Intersection Observer

```astro
<div class="lazy-load" data-src="/images/large-image.jpg">
  <img src="/images/placeholder.jpg" alt="Loading..." />
</div>

<script>
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const img = entry.target.querySelector('img');
        const src = entry.target.dataset.src;
        if (img && src) {
          img.src = src;
          observer.unobserve(entry.target);
        }
      }
    });
  });

  document.querySelectorAll('.lazy-load').forEach(el => {
    observer.observe(el);
  });
</script>
```

## Mesurer les performances

### Lighthouse CI

```bash
npm install -g @lhci/cli

# Générer un rapport
lhci autorun --collect.url=http://localhost:4321
```

### Web Vitals

```astro
---
// src/components/WebVitals.astro
---

<script>
  import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

  function sendToAnalytics(metric: any) {
    console.log(metric);
    // Envoyer à votre service d'analytics
  }

  getCLS(sendToAnalytics);
  getFID(sendToAnalytics);
  getFCP(sendToAnalytics);
  getLCP(sendToAnalytics);
  getTTFB(sendToAnalytics);
</script>
```

## Bundle analysis

```bash
# Analyser la taille des bundles
npm run build
npx vite-bundle-visualizer
```

## Optimisations PocketBase

### Limiter les données retournées

```ts
// Ne récupérer que les champs nécessaires
const events = await pb.collection("event").getList(1, 10, {
  fields: "id,title,date,image,category", // Seulement les champs nécessaires
});
```

### Utiliser le cache

```ts
// Simple cache en mémoire
const cache = new Map<string, { data: any; timestamp: number }>();
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

export async function getCachedEvents(): Promise<Event[]> {
  const cacheKey = "upcoming-events";
  const cached = cache.get(cacheKey);

  if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
    return cached.data;
  }

  const events = await getUpcomingEvents();
  cache.set(cacheKey, { data: events, timestamp: Date.now() });

  return events;
}
```

## Checklist performance

- ✅ Images optimisées (WebP, lazy loading)
- ✅ Fonts optimisées (preload, woff2)
- ✅ CSS minifié et purgé
- ✅ JavaScript minifié
- ✅ Compression gzip/brotli activée
- ✅ Cache HTTP configuré
- ✅ CDN utilisé pour les assets statiques
- ✅ Pagination efficace
- ✅ Requêtes API limitées
- ✅ Core Web Vitals optimisés :
  - LCP < 2.5s
  - FID < 100ms
  - CLS < 0.1
- ✅ Lighthouse score > 90
- ✅ Time to Interactive < 3.8s
- ✅ First Contentful Paint < 1.8s

## Outils de monitoring

- [PageSpeed Insights](https://pagespeed.web.dev/)
- [WebPageTest](https://www.webpagetest.org/)
- [GTmetrix](https://gtmetrix.com/)
- Chrome DevTools (Performance tab)
